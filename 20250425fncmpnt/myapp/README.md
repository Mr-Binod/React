# React의 함수형 컴포넌트

## 리액트는 초기에 class 형 컴포넌트를 사용
> 2013년에 페이스북에서 공개를 하면서 처음 사용했던 컴포넌트는 class
> 생명주기나 상태를 제어할때 클래스형 컴포넌트를 사용해야했다.

```js
class App extends React.Component {
    render() {
        return (
            <div></div >
        )
    }
}

```

## 클래스형 컴포넌트를 사용할때 어려웠던 점
1. 클래스 문법에 익숙하지 많은 사람도 있고 
2. 구조가 복잡해진다. this 바인딩도 해결하고 render 라는 함수도 작성을 해야하고 
3. 구조의 제사용성이 많이 떨어진다. 코드가 너무 길어지고 무거워진다.


## 처음에는  함수형 컴포넌트의 사용은 단순한 UI를 그릴때
> 함수형 컴포는트는 제공이 되었는데 순수하게 UI를 그리는 함수만으로 사용을 했었음
> 생명주기 함수나 상태제어 함수를 사용할수 없었다

```js

// useState 상태변수를 선언해서 사용할수 있는 기능을 제공한다.
const App = () => {
    return <div></div>
} 
```

### Hook 의 탄생
> 기능을 가져온다 라는 표현의 hook 즉 리액트의 기능을 가져와서 사용
> react 가 16 버전 이휴부터 hook 함수를 제공하게 되었다
> react의 기능을 사용할수 있는 함수를 제공이 함수의 내용에는 유용한 기능이 포함되어있다 상태와 생면주기를 제어하는데.
> 클래서 컴포넌트에서만 생명주기와 상태를 다룰수 있었지만 hook이 탄생하고나서
> 함수형 컴포넌트에서도 생명주기와 상태 등의 더옥 상태를 제어하는데 강력한 함수를 제공해주게 되어서 함수형 컴포넌트의 사용도가 많아졌다.

*** 리액트의 공식문서에서 클래스를 배울 필요가 없다 ***
> 함수 이름의 앞에 use가 붙으면 hook 함수다
> 리액트에서 제공하지 않았지만 use가 붙은 함수는요 ? 커스텀 훅
> hook 리액트에서 재사용이 많이 될것같은 기능을 구현할때 (입력창에 값을 입력해서 입력을 할때마다 상태를 업데이트해서 상태 변수에 할당을 해놓는 기능)


### 함수형 컴포넌트의 문법

``` js 
// 함수 이름의 앞에 use가 붙으면 hook 함수다
// 리액트에서 제공하지 않았지만 use가 붙은 함수는요 ? 커스텀 훅
// useState 상태변수를 선언해서 사용할수 있는 기능을 제공한다
// useEffect 생명주기에서 호출할 기능를 정의 콜백의 형태를 띄고있다.
import {useState, useEffect} from "react";  

const App = () => {
    // count : 상태 변수 값
    // setCount
    // useState (초기값)
    // useState 반환값이 배열이고 첫번째 요소는 상태 변수의 값 두번째 요소는 상태변수를 없데이트하는 함수
    const [Count, setCount] = useState(0); 
    // 내가 주시하는 상태가 변환했을때의 조겅을 추가해서 실행해줄게
    // useEffect 생명주기에서 기능을 호출하는데 조건까지 어떤 상태변수가 변화하면 호출할 기능
    // useEffect 첫번째 매개변수로 콜백 함수를 전달해서 생변주기의 때에 호출을 할수있고
    // 두번째 매개변수는 벼열의 값을 전달을 하는데 이 벼열이 빈배열으면 마운트 배열에 주시할 값을 전달하게되면 마운트 + 업데이트 전달한 값이 변경될때마다 호출되는 값
    useEffect(()=>{

    },[]) // 최초에 한번 호출 마운트
    useEffect(()=>{

    },[Count, Name]) // called when Count 이나 Name 변경 될때
    useEffect(()=>{
        if (count === 0) return 
        // 이런 조건을 작성하면 업데데이트만 마운트 제외
        // 업데이트 구문을 사용
        // 언마운트 컴포넌트가 화면에서 사라졌을때 보이지않을때 
        return() => {
            console.log('내가 이제 화면에서 보이지 않을거야')
        }
    },[Count, Name]) // Count 이나 Name 변경 될때
   
    const [Name, setName] = useState('soon'); 

    return <div>
        hello react
    </div>
}
```

### 정리 
> 클래스 컴포넌트를 사용할때 문제접은 클래스의 문법의 이슈로 어려움을 겪었고 유지보수성 즉 가독성의 이슈와 재사용성의 이슈가 있었다
> 함수형 컴포넌트를 사용하는 처음에는 단순하게 ui 의 표현만 가능럤지만 HOOK함수가 탄생하고 나거함수형 컴포넌트의 한계가 극복된것 뿐만 아니라 더 기능이 좋아졌다. 그래서 함수형의 사용도가 높아졌다

1. 코드의 구조는 클래스형은 this 바인딩이 필요하다 함수형은 this 가 없다다
2. 상태 관리를 할때 명확한 표현 this.state.count 클래서형은 이렇게 작성을 하는데 함수형은 이름이 명확하다. setCount 명확한 이름으로 표현 가능 
3. 생명주기 처리 생명주기 메서드를 선언해서 작성해야 하는 방식과 다르게 기능의 구분이 명확하게 가능하다. useEffect는 생명주기를 사용하는데 명확한 상ㄷ태의 주시가 가능하다. 업데이트의 로직을 코드를구분을 정규화
4. 함수 기능의 재사용성 클래스형은 재사용되는 기능을 정리하기 무리가 있다. 함수형 컴포넌트는 커스텀 hook 함수를 만들어서 재사용되는 기능을 작성해서 재사용성을 높일수 있다.
5. 부모가 리렌더링 되면 자식이 모두 리렌더링 되는데 클래스 형에서 자식요소가 그려지는 것에 대한 최적화에 제공되는 기능이 적다. 함수형은 useMemo usecallback 등등



### 함수형 컴포넌트로 가위바위보

1. 플레이어와 컴퓨터가 있고
2. 플레이어와 컴퓨터는 가위 바위 보를 선택할수 있는데 컴퓨터는 랜덤한 값을 가지고 선택
3. 플레이어는 버튼을 눌러서 가위 바위 보를 선택
4. 선택한 결과를 확인하는 때는 플레이러가 벝튼을 눌러서 가위바위보를 선택했을때 비고해서 승패 확인



### 실습 배틴금액 둘다 10000원씩 가지고 있고 
### 승리한 사람에게 1000원을 줘야하는데 
### 이기면 20% ~ 100% 의 추가금액을 상대에게 줘야함 랜덤하게 
### 플레이어 혹은 컴퓨터 둘다 돈이 모두 사라진 쪽이 승리