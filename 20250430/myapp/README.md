# custom hook 

> 리액트에서 제공하는 hook 을 사용해서  기능을 한단계더 추상화 시킨다
> 로직과 컴포넌트 UI 의 구분을 위해서 사용
> 기능을 분리 단순하게 쉽게 말해서 함수다.

### custom hook 의 탄생

> 2018년도 쯤 hook들이 등장햇고 
> useState, useEffect 이런 hook 들이 등장한 시기 이휴에 함수형 컴포넌트가 홀라갔고.
> 이 함수형 컴포넌트의 사용 목적 코드의 간결성 그리고 생명주기도 제어할수 있게 되었고 재사용성이 좋은 기능들.


### 문제점
> 기능의 재사용성을 높이는데 react hook 만으로는 재사용성의 커버가 힘들었다.
> 복잡한 로직의 구분 컴포넌트의 내용에 기능이 포함되다 보면 모든 컴포넌트에서 재사용되는 기능들을 구분하기 힘들다.


### 커스텀 훌이 문제점 해결
> 리액트 훅의 네이밍을 기반으로 우리가 직접 만든 함수로 공통 로직을 재사용성을 높여서 추상화
> 이름은 use 를 꼭 붙여서 제얏을 ㄱㄹ고 사용해야한다. 리앳트는 custom hook 만들때 use 를 이름앞에 꼭 분여줘야한다.
> useInput : 예) 입력값을 상태변수로 저장하고 있게하는 기능


### 커스텀 휵의 목적성
- 로직의 재사용 : 여러 컴포넌트들에서 자주 사용되는 기능을 정의 
- 컴포넌트와 기능의 분리 : 컴포넌트의 내부에 기능을 모두 작성하지않고 유지보수와 코드의 가독성을 높이기 위해서 기능을 분리

### 커스텀 훅의 동작 원리
> 리앳트 상태변수는 컴포넌트에서 hook이 호출될때 내부적으로 저장을 하는데
> 이 로직을 커스텀 훅에 상태를 저장해서 반환
> 기본 리액트에서 제공하는 hook 과 같은 규칙에 맞게 동작을 제공한다.

```js

// 카운트 동작을 하는 컴포넌트는 모두 이 커스텀 훅을 재사용 할수 있다.
// 커스텀 훅은 내부적으로 훅을 가지고 있고 상태변수의 변화를 컴포넌트에서 작성하지않고
// 훅을 사용한 상태변화를 통해 작성한 기능을 추상화는 역활을 한다.
const useCount = () => {
    const[count, setCount] = useState(0);

    // 로직 처리를 내부에서 처리하고
    // 기능의 추상화화
    const increment = () => {
        setCount((prev => prev + 1))
    }

    return {count, increment}
}
```

### 모바일 버전 로그인 로직
> 입력값을 상태변수로 저장할 로직이 필요
> axios 요청 보낼 로직이 필요하고. (새로고침을 하지않고 동적인 내용)
> 로딩에대한 버튼의 ui


```sh
npm i axios

```